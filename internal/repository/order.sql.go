// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: order.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (representative_id, factory_id, customer_id, portage_id, seller_id, form_payment_id,
                    order_number, url_pdf, buyer, shipping, status, created_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
RETURNING id, representative_id, factory_id, customer_id, portage_id, seller_id, form_payment_id, order_number, url_pdf, buyer, shipping, status, expired_at, total, is_active, created_at, updated_at
`

type CreateOrderParams struct {
	RepresentativeID int32
	FactoryID        int32
	CustomerID       int32
	PortageID        int32
	SellerID         int32
	FormPaymentID    sql.NullInt32
	OrderNumber      int32
	UrlPdf           sql.NullString
	Buyer            sql.NullString
	Shipping         ShippingEnum
	Status           StatusEnum
	CreatedAt        time.Time
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, createOrder,
		arg.RepresentativeID,
		arg.FactoryID,
		arg.CustomerID,
		arg.PortageID,
		arg.SellerID,
		arg.FormPaymentID,
		arg.OrderNumber,
		arg.UrlPdf,
		arg.Buyer,
		arg.Shipping,
		arg.Status,
		arg.CreatedAt,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RepresentativeID,
		&i.FactoryID,
		&i.CustomerID,
		&i.PortageID,
		&i.SellerID,
		&i.FormPaymentID,
		&i.OrderNumber,
		&i.UrlPdf,
		&i.Buyer,
		&i.Shipping,
		&i.Status,
		&i.ExpiredAt,
		&i.Total,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteOrderByID = `-- name: DeleteOrderByID :one
UPDATE orders
SET is_active  = FALSE,
    updated_at = NOW()
WHERE id = $1
  AND is_active = TRUE
RETURNING id, representative_id, factory_id, customer_id, portage_id, seller_id, form_payment_id, order_number, url_pdf, buyer, shipping, status, expired_at, total, is_active, created_at, updated_at
`

func (q *Queries) DeleteOrderByID(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, deleteOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RepresentativeID,
		&i.FactoryID,
		&i.CustomerID,
		&i.PortageID,
		&i.SellerID,
		&i.FormPaymentID,
		&i.OrderNumber,
		&i.UrlPdf,
		&i.Buyer,
		&i.Shipping,
		&i.Status,
		&i.ExpiredAt,
		&i.Total,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getLastOrderByRepresentativeID = `-- name: GetLastOrderByRepresentativeID :one
SELECT order_number
from orders
WHERE representative_id = $1
ORDER BY id DESC
LIMIT 1
`

func (q *Queries) GetLastOrderByRepresentativeID(ctx context.Context, representativeID int32) (int32, error) {
	row := q.db.QueryRowContext(ctx, getLastOrderByRepresentativeID, representativeID)
	var order_number int32
	err := row.Scan(&order_number)
	return order_number, err
}

const getOrderByID = `-- name: GetOrderByID :one
SELECT f.name  AS factory_name,
       c.name  AS customer_name,
       p.name  AS portage_name,
       s.name  AS seller_name,
       s.email  AS seller_email,
       c.email  AS customer_email,
       fp.name AS form_payment_name,
       c.cnpj AS customer_cnpj,
       f.cnpj AS factory_cnpj,
       o.id, o.representative_id, o.factory_id, o.customer_id, o.portage_id, o.seller_id, o.form_payment_id, o.order_number, o.url_pdf, o.buyer, o.shipping, o.status, o.expired_at, o.total, o.is_active, o.created_at, o.updated_at
FROM orders o
         JOIN companies f
              ON o.factory_id = f.id
         JOIN companies c
              ON o.customer_id = c.id
         JOIN companies p
              ON o.portage_id = p.id
         JOIN sellers s
              ON o.seller_id = s.id
         LEFT JOIN form_payments fp
              ON o.form_payment_id = fp.id
WHERE o.id = $1
`

type GetOrderByIDRow struct {
	FactoryName      string
	CustomerName     string
	PortageName      string
	SellerName       string
	SellerEmail      sql.NullString
	CustomerEmail    sql.NullString
	FormPaymentName  sql.NullString
	CustomerCnpj     sql.NullString
	FactoryCnpj      sql.NullString
	ID               int32
	RepresentativeID int32
	FactoryID        int32
	CustomerID       int32
	PortageID        int32
	SellerID         int32
	FormPaymentID    sql.NullInt32
	OrderNumber      int32
	UrlPdf           sql.NullString
	Buyer            sql.NullString
	Shipping         ShippingEnum
	Status           StatusEnum
	ExpiredAt        time.Time
	Total            string
	IsActive         bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) GetOrderByID(ctx context.Context, id int32) (GetOrderByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getOrderByID, id)
	var i GetOrderByIDRow
	err := row.Scan(
		&i.FactoryName,
		&i.CustomerName,
		&i.PortageName,
		&i.SellerName,
		&i.SellerEmail,
		&i.CustomerEmail,
		&i.FormPaymentName,
		&i.CustomerCnpj,
		&i.FactoryCnpj,
		&i.ID,
		&i.RepresentativeID,
		&i.FactoryID,
		&i.CustomerID,
		&i.PortageID,
		&i.SellerID,
		&i.FormPaymentID,
		&i.OrderNumber,
		&i.UrlPdf,
		&i.Buyer,
		&i.Shipping,
		&i.Status,
		&i.ExpiredAt,
		&i.Total,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listOrdersByRepresentativeID = `-- name: ListOrdersByRepresentativeID :many
SELECT f.name  AS factory_name,
       c.name  AS customer_name,
       p.name  AS portage_name,
       s.name  AS seller_name,
       s.email  AS seller_email,
       c.email  AS customer_email,
       fp.name AS form_payment_name,
       o.id, o.representative_id, o.factory_id, o.customer_id, o.portage_id, o.seller_id, o.form_payment_id, o.order_number, o.url_pdf, o.buyer, o.shipping, o.status, o.expired_at, o.total, o.is_active, o.created_at, o.updated_at
FROM orders o
         JOIN companies f
              ON o.factory_id = f.id
         JOIN companies c
              ON o.customer_id = c.id
         JOIN companies p
              ON o.portage_id = p.id
         JOIN sellers s
              ON o.seller_id = s.id
         LEFT JOIN form_payments fp
              ON o.form_payment_id = fp.id
WHERE o.representative_id = $1
  AND o.is_active = $2
ORDER BY o.id DESC
`

type ListOrdersByRepresentativeIDParams struct {
	RepresentativeID int32
	IsActive         bool
}

type ListOrdersByRepresentativeIDRow struct {
	FactoryName      string
	CustomerName     string
	PortageName      string
	SellerName       string
	SellerEmail      sql.NullString
	CustomerEmail    sql.NullString
	FormPaymentName  sql.NullString
	ID               int32
	RepresentativeID int32
	FactoryID        int32
	CustomerID       int32
	PortageID        int32
	SellerID         int32
	FormPaymentID    sql.NullInt32
	OrderNumber      int32
	UrlPdf           sql.NullString
	Buyer            sql.NullString
	Shipping         ShippingEnum
	Status           StatusEnum
	ExpiredAt        time.Time
	Total            string
	IsActive         bool
	CreatedAt        time.Time
	UpdatedAt        time.Time
}

func (q *Queries) ListOrdersByRepresentativeID(ctx context.Context, arg ListOrdersByRepresentativeIDParams) ([]ListOrdersByRepresentativeIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listOrdersByRepresentativeID, arg.RepresentativeID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ListOrdersByRepresentativeIDRow{}
	for rows.Next() {
		var i ListOrdersByRepresentativeIDRow
		if err := rows.Scan(
			&i.FactoryName,
			&i.CustomerName,
			&i.PortageName,
			&i.SellerName,
			&i.SellerEmail,
			&i.CustomerEmail,
			&i.FormPaymentName,
			&i.ID,
			&i.RepresentativeID,
			&i.FactoryID,
			&i.CustomerID,
			&i.PortageID,
			&i.SellerID,
			&i.FormPaymentID,
			&i.OrderNumber,
			&i.UrlPdf,
			&i.Buyer,
			&i.Shipping,
			&i.Status,
			&i.ExpiredAt,
			&i.Total,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeOrderByID = `-- name: RemoveOrderByID :one
DELETE
FROM orders
WHERE id = $1
RETURNING id, representative_id, factory_id, customer_id, portage_id, seller_id, form_payment_id, order_number, url_pdf, buyer, shipping, status, expired_at, total, is_active, created_at, updated_at
`

func (q *Queries) RemoveOrderByID(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, removeOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RepresentativeID,
		&i.FactoryID,
		&i.CustomerID,
		&i.PortageID,
		&i.SellerID,
		&i.FormPaymentID,
		&i.OrderNumber,
		&i.UrlPdf,
		&i.Buyer,
		&i.Shipping,
		&i.Status,
		&i.ExpiredAt,
		&i.Total,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const restoreOrderByID = `-- name: RestoreOrderByID :one
UPDATE orders
SET is_active  = TRUE,
    updated_at = NOW()
WHERE id = $1
  AND is_active = FALSE
RETURNING id, representative_id, factory_id, customer_id, portage_id, seller_id, form_payment_id, order_number, url_pdf, buyer, shipping, status, expired_at, total, is_active, created_at, updated_at
`

func (q *Queries) RestoreOrderByID(ctx context.Context, id int32) (Order, error) {
	row := q.db.QueryRowContext(ctx, restoreOrderByID, id)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RepresentativeID,
		&i.FactoryID,
		&i.CustomerID,
		&i.PortageID,
		&i.SellerID,
		&i.FormPaymentID,
		&i.OrderNumber,
		&i.UrlPdf,
		&i.Buyer,
		&i.Shipping,
		&i.Status,
		&i.ExpiredAt,
		&i.Total,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateOrderByID = `-- name: UpdateOrderByID :one
UPDATE orders
SET factory_id      = COALESCE($2, factory_id),
    customer_id     = COALESCE($3, customer_id),
    portage_id      = COALESCE($4, portage_id),
    seller_id       = COALESCE($5, seller_id),
    form_payment_id = COALESCE($6, form_payment_id),
    url_pdf         = COALESCE($7, url_pdf),
    buyer           = COALESCE($8, buyer),
    shipping        = COALESCE($9, shipping),
    status          = COALESCE($10, status),
    expired_at      = COALESCE($11, expired_at),
    created_at      = COALESCE($12, created_at),
    updated_at      = NOW()
WHERE id = $1
RETURNING id, representative_id, factory_id, customer_id, portage_id, seller_id, form_payment_id, order_number, url_pdf, buyer, shipping, status, expired_at, total, is_active, created_at, updated_at
`

type UpdateOrderByIDParams struct {
	ID            int32
	FactoryID     sql.NullInt32
	CustomerID    sql.NullInt32
	PortageID     sql.NullInt32
	SellerID      sql.NullInt32
	FormPaymentID sql.NullInt32
	UrlPdf        sql.NullString
	Buyer         sql.NullString
	Shipping      NullShippingEnum
	Status        NullStatusEnum
	ExpiredAt     sql.NullTime
	CreatedAt     sql.NullTime
}

func (q *Queries) UpdateOrderByID(ctx context.Context, arg UpdateOrderByIDParams) (Order, error) {
	row := q.db.QueryRowContext(ctx, updateOrderByID,
		arg.ID,
		arg.FactoryID,
		arg.CustomerID,
		arg.PortageID,
		arg.SellerID,
		arg.FormPaymentID,
		arg.UrlPdf,
		arg.Buyer,
		arg.Shipping,
		arg.Status,
		arg.ExpiredAt,
		arg.CreatedAt,
	)
	var i Order
	err := row.Scan(
		&i.ID,
		&i.RepresentativeID,
		&i.FactoryID,
		&i.CustomerID,
		&i.PortageID,
		&i.SellerID,
		&i.FormPaymentID,
		&i.OrderNumber,
		&i.UrlPdf,
		&i.Buyer,
		&i.Shipping,
		&i.Status,
		&i.ExpiredAt,
		&i.Total,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
