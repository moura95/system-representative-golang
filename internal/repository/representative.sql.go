// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: representative.sql

package repository

import (
	"context"
	"database/sql"
	"time"
)

const createRepresentative = `-- name: CreateRepresentative :one
INSERT INTO representatives (cnpj, name, email, website, logo_url, street, number, city,
                             state, zip_code, fantasy_name, ie, phone)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
RETURNING id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
`

type CreateRepresentativeParams struct {
	Cnpj        sql.NullString
	Name        sql.NullString
	Email       sql.NullString
	Website     sql.NullString
	LogoUrl     sql.NullString
	Street      sql.NullString
	Number      sql.NullString
	City        sql.NullString
	State       sql.NullString
	ZipCode     sql.NullString
	FantasyName sql.NullString
	Ie          sql.NullString
	Phone       sql.NullString
}

func (q *Queries) CreateRepresentative(ctx context.Context, arg CreateRepresentativeParams) (Representative, error) {
	row := q.db.QueryRowContext(ctx, createRepresentative,
		arg.Cnpj,
		arg.Name,
		arg.Email,
		arg.Website,
		arg.LogoUrl,
		arg.Street,
		arg.Number,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.FantasyName,
		arg.Ie,
		arg.Phone,
	)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteRepresentativeByID = `-- name: DeleteRepresentativeByID :one
UPDATE representatives
SET is_active  = FALSE,
    updated_at = NOW()
WHERE id = $1
  AND is_active = TRUE
RETURNING id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
`

func (q *Queries) DeleteRepresentativeByID(ctx context.Context, id int32) (Representative, error) {
	row := q.db.QueryRowContext(ctx, deleteRepresentativeByID, id)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAllRepresentativesByID = `-- name: GetAllRepresentativesByID :many
SELECT id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
FROM representatives
`

func (q *Queries) GetAllRepresentativesByID(ctx context.Context) ([]Representative, error) {
	rows, err := q.db.QueryContext(ctx, getAllRepresentativesByID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Representative{}
	for rows.Next() {
		var i Representative
		if err := rows.Scan(
			&i.ID,
			&i.Cnpj,
			&i.Name,
			&i.FantasyName,
			&i.Ie,
			&i.Phone,
			&i.Email,
			&i.Website,
			&i.LogoUrl,
			&i.ZipCode,
			&i.State,
			&i.City,
			&i.Street,
			&i.Number,
			&i.Plan,
			&i.StripeID,
			&i.DataExpire,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlanByRepresentativesID = `-- name: GetPlanByRepresentativesID :one
SELECT plan
FROM representatives
WHERE id = $1
`

func (q *Queries) GetPlanByRepresentativesID(ctx context.Context, id int32) (PlanTypes, error) {
	row := q.db.QueryRowContext(ctx, getPlanByRepresentativesID, id)
	var plan PlanTypes
	err := row.Scan(&plan)
	return plan, err
}

const getRepresentativeDateExpByID = `-- name: GetRepresentativeDateExpByID :one
SELECT data_expire
FROM representatives
WHERE id = $1
`

func (q *Queries) GetRepresentativeDateExpByID(ctx context.Context, id int32) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getRepresentativeDateExpByID, id)
	var data_expire time.Time
	err := row.Scan(&data_expire)
	return data_expire, err
}

const getRepresentativesByID = `-- name: GetRepresentativesByID :one
SELECT id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
FROM representatives
WHERE id = $1
`

func (q *Queries) GetRepresentativesByID(ctx context.Context, id int32) (Representative, error) {
	row := q.db.QueryRowContext(ctx, getRepresentativesByID, id)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTotalUsersByRepresentativesID = `-- name: GetTotalUsersByRepresentativesID :one
SELECT COUNT(*)
FROM users
WHERE representative_id = $1
`

func (q *Queries) GetTotalUsersByRepresentativesID(ctx context.Context, representativeID int32) (int64, error) {
	row := q.db.QueryRowContext(ctx, getTotalUsersByRepresentativesID, representativeID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const removeRepresentativeByID = `-- name: RemoveRepresentativeByID :one
DELETE
FROM representatives
WHERE id = $1
RETURNING id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
`

func (q *Queries) RemoveRepresentativeByID(ctx context.Context, id int32) (Representative, error) {
	row := q.db.QueryRowContext(ctx, removeRepresentativeByID, id)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const restoreRepresentativeByID = `-- name: RestoreRepresentativeByID :one
UPDATE representatives
SET is_active  = TRUE,
    updated_at = NOW()
WHERE id = $1
  AND is_active = FALSE
RETURNING id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
`

func (q *Queries) RestoreRepresentativeByID(ctx context.Context, id int32) (Representative, error) {
	row := q.db.QueryRowContext(ctx, restoreRepresentativeByID, id)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlanByID = `-- name: UpdatePlanByID :one
UPDATE representatives
SET plan        = $2,
    is_active   = TRUE,
    stripe_id   = $3,
    data_expire = $4,
    updated_at  = NOW()
WHERE id = $1
RETURNING id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
`

type UpdatePlanByIDParams struct {
	ID         int32
	Plan       PlanTypes
	StripeID   sql.NullString
	DataExpire time.Time
}

func (q *Queries) UpdatePlanByID(ctx context.Context, arg UpdatePlanByIDParams) (Representative, error) {
	row := q.db.QueryRowContext(ctx, updatePlanByID,
		arg.ID,
		arg.Plan,
		arg.StripeID,
		arg.DataExpire,
	)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRepresentativeByID = `-- name: UpdateRepresentativeByID :one
UPDATE representatives
SET name         = COALESCE($2, name),
    email        = COALESCE($3, email),
    website      = COALESCE($4, website),
    logo_url     = COALESCE($5, logo_url),
    street       = COALESCE($6, street),
    number       = COALESCE($7, number),
    city         = COALESCE($8, city),
    state        = COALESCE($9, state),
    zip_code     = COALESCE($10, zip_code),
    cnpj         = COALESCE($11, cnpj),
    fantasy_name = COALESCE($12, fantasy_name),
    ie           = COALESCE($13, ie),
    phone        = COALESCE($14, phone),
    updated_at   = NOW()
WHERE id = $1
RETURNING id, cnpj, name, fantasy_name, ie, phone, email, website, logo_url, zip_code, state, city, street, number, plan, stripe_id, data_expire, is_active, created_at, updated_at
`

type UpdateRepresentativeByIDParams struct {
	ID          int32
	Name        sql.NullString
	Email       sql.NullString
	Website     sql.NullString
	LogoUrl     sql.NullString
	Street      sql.NullString
	Number      sql.NullString
	City        sql.NullString
	State       sql.NullString
	ZipCode     sql.NullString
	Cnpj        sql.NullString
	FantasyName sql.NullString
	Ie          sql.NullString
	Phone       sql.NullString
}

func (q *Queries) UpdateRepresentativeByID(ctx context.Context, arg UpdateRepresentativeByIDParams) (Representative, error) {
	row := q.db.QueryRowContext(ctx, updateRepresentativeByID,
		arg.ID,
		arg.Name,
		arg.Email,
		arg.Website,
		arg.LogoUrl,
		arg.Street,
		arg.Number,
		arg.City,
		arg.State,
		arg.ZipCode,
		arg.Cnpj,
		arg.FantasyName,
		arg.Ie,
		arg.Phone,
	)
	var i Representative
	err := row.Scan(
		&i.ID,
		&i.Cnpj,
		&i.Name,
		&i.FantasyName,
		&i.Ie,
		&i.Phone,
		&i.Email,
		&i.Website,
		&i.LogoUrl,
		&i.ZipCode,
		&i.State,
		&i.City,
		&i.Street,
		&i.Number,
		&i.Plan,
		&i.StripeID,
		&i.DataExpire,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
